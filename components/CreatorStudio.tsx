
import React, { useEffect, useRef, useCallback } from 'react';
import { CreatorStudioProject, ImageFile } from '../types';
import { analyzeStyleImage, translateText, generateImage, editImage } from '../services/geminiService';
import { resizeImage } from '../utils';
import CustomizationPanel from './CustomizationPanel';
import ImageWorkspace from './ImageWorkspace';
import PromptEditor from './PromptEditor';
import HistoryPanel from './HistoryPanel';
import ResultDisplay from './ResultDisplay';

interface CreatorStudioProps {
  project: CreatorStudioProject;
  setProject: React.Dispatch<React.SetStateAction<CreatorStudioProject>>;
}

const CreatorStudio: React.FC<CreatorStudioProps> = ({
  project,
  setProject,
}) => {
  
  const translateTimeoutRef = useRef<number | null>(null);
  const translationRequestCounter = useRef(0);

  const updateActiveProjectState = useCallback((updater: (projectDraft: CreatorStudioProject) => void) => {
    setProject(currentProject => {
      const projectToUpdate = { ...currentProject };
      updater(projectToUpdate);
      return projectToUpdate;
    });
  }, [setProject]);

  // Analyze style image
  useEffect(() => {
    if (project?.styleImages?.length > 0 && !project.styleDescription && !project.isAnalyzingStyle && !project.error) {
      const getStyleDescription = async () => {
        updateActiveProjectState(p => { 
          p.isAnalyzingStyle = true;
          p.error = null;
        });
        try {
          const description = await analyzeStyleImage(project.styleImages);
          updateActiveProjectState(p => { p.styleDescription = description; });
        } catch (err) {
          console.error(err);
          updateActiveProjectState(p => {
            p.error = err instanceof Error ? err.message : "Could not analyze the style image.";
            p.styleDescription = null;
          });
        } finally {
          updateActiveProjectState(p => { p.isAnalyzingStyle = false; });
        }
      };
      getStyleDescription();
    } else if (project?.styleImages?.length === 0 && project?.styleDescription) {
      updateActiveProjectState(p => { p.styleDescription = null; });
    }
  }, [
    project?.id,
    project?.styleImages, 
    project?.styleDescription,
    project?.isAnalyzingStyle,
    project?.error,
    updateActiveProjectState
  ]);

  // Auto-generate prompt - MODIFIED: only fills if empty and auto-mode is ON
  useEffect(() => {
    if (!project || !project.isPromptAutoGenerated) return;
    
    const { productImages, styleImages, options, isAnalyzingStyle, styleDescription } = project;
    
    if (productImages.length === 0 && styleImages.length === 0) {
      return;
    }

    let newPrompt = `Professional high-end commercial photograph`;
    if (productImages.length > 0) {
      newPrompt += ` of the subject from the provided image`;
    }
    
    newPrompt += `. 

Setting: Place the subject in a sophisticated and professional new environment that captures the essence, mood, and background aesthetic of the style reference. The background should be a high-quality reimagining inspired by the style reference, ensuring it complements the subject perfectly.

Key requirements:
- Lighting: ${options.lightingStyle} with professional studio quality.
- Perspective: ${options.cameraPerspective}.
- Mood: High-end, clean, and professional.
- Content Protection: STRICTLY PRESERVE all original text, labels, and branding on the product. DO NOT erase or modify existing writing. NO EXTRA generated text in the scene. 8k resolution, sharp focus, hyper-realistic.`;

    if (styleImages.length > 0) {
      if (isAnalyzingStyle) newPrompt += `\n- Visual Inspiration: Reimagining the reference style...`;
      else if (styleDescription) newPrompt += `\n- Background/Style Essence: ${styleDescription}. Create a similar professional atmosphere.`;
      else newPrompt += `\n- Background/Style Essence: Resembling the provided style reference atmosphere and lighting.`;
    }
    
    if(project.prompt === '') updateActiveProjectState(p => { p.prompt = newPrompt; });
  }, [
    project?.id,
    project?.isPromptAutoGenerated,
    project?.productImages, 
    project?.styleImages, 
    project?.options, 
    project?.isAnalyzingStyle, 
    project?.styleDescription,
    updateActiveProjectState
  ]);

  // Translation effect
  useEffect(() => {
    const arabicRegex = /[\u0600-\u06FF]/;
    if (!project || project.isPromptAutoGenerated) {
        if (project?.translatedPrompt || project?.isTranslating) {
            updateActiveProjectState(p => { p.translatedPrompt = null; p.isTranslating = false; });
        }
        return;
    }

    if (translateTimeoutRef.current) clearTimeout(translateTimeoutRef.current);
    const promptToTranslate = project.prompt;

    if (!arabicRegex.test(promptToTranslate) || !promptToTranslate.trim()) {
        if (project.translatedPrompt || project.isTranslating) {
            updateActiveProjectState(p => { p.translatedPrompt = null; p.isTranslating = false; });
        }
        return;
    }

    translateTimeoutRef.current = window.setTimeout(async () => {
        translationRequestCounter.current += 1;
        const currentRequestId = translationRequestCounter.current;
        updateActiveProjectState(p => { p.isTranslating = true; p.error = null; });

        try {
            const translated = await translateText(promptToTranslate);
            if (translationRequestCounter.current === currentRequestId) {
                updateActiveProjectState(p => { if (p.prompt === promptToTranslate) p.translatedPrompt = translated; });
            }
        } catch (err) {
            console.error(err);
            if (translationRequestCounter.current === currentRequestId) {
                updateActiveProjectState(p => { p.error = err instanceof Error ? err.message : 'Translation failed.'; });
            }
        } finally {
            if (translationRequestCounter.current === currentRequestId) {
                updateActiveProjectState(p => { p.isTranslating = false; });
            }
        }
    }, 700);
  }, [project?.prompt, project?.isPromptAutoGenerated, updateActiveProjectState]);
  
  const handleGenerate = useCallback(async () => {
    if (!project || !project.prompt) {
      updateActiveProjectState(p => { p.error = 'Please write a prompt or select a mode.'; });
      return;
    }
    const currentPrompt = project.prompt;
    updateActiveProjectState(p => { p.isLoading = true; p.error = null; p.generatedImage = null; });

    try {
      const result = await generateImage(project.productImages, project.prompt, project.styleImages);
      updateActiveProjectState(p => {
          p.generatedImage = result;
          p.history = [{ image: result, prompt: currentPrompt }, ...p.history];
      });
    } catch (err) {
      console.error(err);
      updateActiveProjectState(p => { p.error = err instanceof Error ? err.message : 'Generation failed.'; });
    } finally {
      updateActiveProjectState(p => { p.isLoading = false; });
    }
  }, [project, updateActiveProjectState]);

  // Logic for Step 1: APPLY STOCK BASE
  const handleApplyStockBase = useCallback(() => {
    if (!project) return;
    const current = project.prompt.trim();
    const baseText = current && !current.includes("Stock photo") ? current : "the product";
    
    const updatedPrompt = `Stock photo of ${baseText}, pure white background, professional commercial photography, high-end studio lighting, sophisticated white rim lighting accents, 8k resolution, sharp focus, hyper-realistic, extremely high detail. STRICTLY PRESERVE original branding. NO EXTRA generated text.`;
    
    updateActiveProjectState(p => { 
        p.prompt = updatedPrompt; 
        p.isPromptAutoGenerated = false;
    });
  }, [project, updateActiveProjectState]);

  // NEW: Handle AI Vision Modes
  const handleApplyVisionMode = useCallback((mode: 'fusion' | 'placement') => {
    if (!project) return;
    const { styleDescription } = project;
    
    let updatedPrompt = '';
    const textConstraint = "STRICTLY PRESERVE all original text, labels, and branding. DO NOT modify existing writing. NO EXTRA generated text in the scene.";

    if (mode === 'fusion') {
        updatedPrompt = `Professional Style Fusion: Take the subject from the main image and seamlessly re-render it using the visual style, professional lighting, and artistic mood of the reference image. ${styleDescription ? `Reference context: ${styleDescription}.` : ''} High-end commercial quality, 8k resolution, photorealistic. ${textConstraint}`;
    } else {
        updatedPrompt = `Professional Scene Placement: Extract the subject from the main image and place it professionally into the exact environment, background, and spatial context of the reference image. ${styleDescription ? `Reference context: ${styleDescription}.` : ''} Match the lighting, shadows, and perspective of the reference perfectly for a hyper-realistic result. ${textConstraint}`;
    }
    
    updateActiveProjectState(p => { 
        p.prompt = updatedPrompt; 
        p.isPromptAutoGenerated = false;
    });
  }, [project, updateActiveProjectState]);

  // Logic for Step 2: CHANGE RIM COLOR
  const handleApplyRimColor = useCallback((color: string) => {
    if (!project) return;
    const current = project.prompt;
    
    if (current.includes("rim lighting")) {
        const regex = /(\w+)\s+rim lighting/;
        const updated = current.replace(regex, `${color} rim lighting`);
        updateActiveProjectState(p => { p.prompt = updated; });
    } else {
        updateActiveProjectState(p => { p.prompt = `${current} with ${color} rim lighting accents.`; });
    }
  }, [project, updateActiveProjectState]);

  const handleImageEdit = async (editPromptText: string) => {
    if (!project.generatedImage) return;
    
    updateActiveProjectState(p => { p.isEditing = true; p.error = null; });
    try {
        const result = await editImage(project.generatedImage as ImageFile, editPromptText);
        updateActiveProjectState(p => {
            p.generatedImage = result;
            p.history = [{ image: result, prompt: editPromptText }, ...p.history];
        });
    } catch (err) {
        updateActiveProjectState(p => { p.error = err instanceof Error ? err.message : 'Edit failed'; });
    } finally {
        updateActiveProjectState(p => { p.isEditing = false; });
    }
  };


  const handleFileUpload = (updater: (files: ImageFile[]) => void, target: 'product' | 'style') => async (files: File[]) => {
      if (!files || files.length === 0) return;
      updateActiveProjectState(p => { p.uploadingTarget = target; p.error = null; });
      let currentError: string | null = null;
      
      const filePromises = files.map(file => {
          return new Promise<ImageFile | null>(async (resolve) => {
              if (!file.type.startsWith('image/')) {
                  if(!currentError) currentError = `File '${file.name}' not supported.`;
                  resolve(null); return;
              }
              try {
                  const resizedFile = await resizeImage(file, 2048, 2048);
                  const reader = new FileReader();
                  reader.onloadend = () => {
                      resolve({ base64: (reader.result as string).split(',')[1], mimeType: resizedFile.type, name: resizedFile.name });
                  };
                  reader.readAsDataURL(resizedFile);
              } catch (err) {
                  resolve(null);
              }
          });
      });

      const results = await Promise.all(filePromises);
      const validImages = results.filter((img): img is ImageFile => img !== null);
      if (validImages.length > 0) updater(validImages);
      updateActiveProjectState(p => { p.error = currentError; p.uploadingTarget = null; });
  };
  
  const handleSetPrompt = (prompt: string) => updateActiveProjectState(p => {
    p.prompt = prompt;
    p.isPromptAutoGenerated = false;
  });

  if (!project) return null;

  return (
    <main className="w-full grid grid-cols-1 lg:grid-cols-2 gap-8 pt-4 pb-12 items-start">
        <div className="flex flex-col gap-6 order-1">
            <div className="grid grid-cols-2 gap-4">
                <div className="glass-card p-3 rounded-2xl flex flex-col gap-2 items-center border border-white/5">
                    <h3 className="text-[10px] font-black text-white/40 uppercase tracking-widest">Main Product</h3>
                    <ImageWorkspace
                        id="creator-product-uploader"
                        images={project.productImages}
                        onImagesUpload={handleFileUpload(files => updateActiveProjectState(p => { p.productImages = [...p.productImages, ...files]; }), 'product')}
                        onImageRemove={(idx) => updateActiveProjectState(p => { p.productImages = p.productImages.filter((_, i) => i !== idx); })}
                        isUploading={project.uploadingTarget === 'product'}
                        onImageUpdate={(idx, img) => updateActiveProjectState(p => { p.productImages[idx] = img; })}
                    />
                </div>
                <div className="glass-card p-3 rounded-2xl flex flex-col gap-2 items-center border border-white/5">
                    <h3 className="text-[10px] font-black text-white/40 uppercase tracking-widest">Style Reference</h3>
                    <ImageWorkspace 
                        id="creator-style-uploader"
                        title="Style Image"
                        images={project.styleImages}
                        onImagesUpload={handleFileUpload(files => updateActiveProjectState(p => { p.styleImages = [...p.styleImages, ...files]; p.styleDescription = null; }), 'style')}
                        onImageRemove={(idx) => updateActiveProjectState(p => { p.styleImages = p.styleImages.filter((_, i) => i !== idx); p.styleDescription = null; })}
                        isUploading={project.uploadingTarget === 'style'}
                        onImageUpdate={(idx, img) => updateActiveProjectState(p => { p.styleImages[idx] = img; p.styleDescription = null; })}
                    />
                </div>
            </div>

            <CustomizationPanel options={project.options} setOptions={(opt) => updateActiveProjectState(p => { p.options = opt; })} />

            <PromptEditor
                prompt={project.prompt}
                setPrompt={handleSetPrompt}
                isAutoGenerated={project.isPromptAutoGenerated}
                onResetPrompt={() => updateActiveProjectState(p => { p.isPromptAutoGenerated = !p.isPromptAutoGenerated; })}
                translatedPrompt={project.translatedPrompt}
                isTranslating={project.isTranslating}
                onUseTranslation={(t) => updateActiveProjectState(p => { p.prompt = t; p.isPromptAutoGenerated = false; p.translatedPrompt = null; })}
                onApplyStockBase={handleApplyStockBase}
                onApplyRimColor={handleApplyRimColor}
                onApplyVisionMode={handleApplyVisionMode}
            />

            <button
                onClick={handleGenerate}
                disabled={project.isLoading || !project.prompt || !!project.uploadingTarget}
                className="w-full bg-[var(--color-accent)] hover:bg-[var(--color-accent-dark)] text-white font-black py-5 rounded-2xl text-lg shadow-xl shadow-[var(--color-accent)]/20 transition-all transform active:scale-95 disabled:opacity-50 disabled:transform-none uppercase tracking-widest"
            >
                {project.isLoading ? 'Generating Design...' : 'Generate AI Image'}
            </button>

            {project.error && <div className="bg-red-500/10 border border-red-500/20 text-red-400 px-4 py-3 rounded-xl text-xs font-bold text-center uppercase tracking-tight">{project.error}</div>}
        </div>

        <div className="flex flex-col gap-6 order-2">
             <div className="glass-card rounded-3xl p-6 min-h-[400px] border border-white/5 shadow-2xl">
                <ResultDisplay 
                    imageFile={project.generatedImage} 
                    isLoading={project.isLoading}
                    onEdit={handleImageEdit}
                    isEditing={project.isEditing}
                />
             </div>
            <HistoryPanel history={project.history} onSelect={(img) => updateActiveProjectState(p => { p.generatedImage = img; })} />
        </div>
    </main>
  );
};

export default CreatorStudio;
